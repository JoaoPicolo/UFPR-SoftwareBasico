Comentários sobre a implementação:

Dentro do nosso projeto decidimos por implementar a divisão de blocos, por exemplo: no primeiro momento que alocamos um bloco de 4096 bytes para um ponteiro de 100 bytes teremos a heap estruturada da seguinte forma: 16 bytes para as informações gerenciais do ponteiro, os 100 bytes do ponteiro, 16 bytes para as informações gerenciais do bloco restante e por fim os 3964 bytes restantes.

Ainda quando um bloco retornado possui tamanho maior que o necessário, fazemos novamente está divisão. No caso da segunda alocação do programa "avalia.c", o bloco retornado será o de 3964 bytes restantes citado anteriormente e com a alocação nossa heap ficará da seguinte forma a partir deste bloco: 16 bytes para as informações gerenciais do novo ponteiro, os 130 bytes requeridos, 16 bytes para as informações gerencias do bloco dividido e por fim os 3818 bytes restantes.

Note que neste caso poderemos encontrar a seguinte situação (como ocorreu na alocação da variável "e" na linha 32 do programa "avalia.c"): iremos alocar 10 bytes em um bloco livre contendo 24 bytes. As informações gerenciais do novo ponteiro ocuparão o espaço das informações gerenciais já alocadas para aquele bloco, iremos alocar então os 10 bytes necessários para o novo ponteiro fazendo com que hajam 14 bytes "livres" na memória.
Como nestes 14 bytes não cabem informações gerencias (16 bytes são necessários), não é possível que nem mesmo consideremos o que vem a seguir como um bloco com 0 bytes livres de conteúdo. Desta forma, ao invés de dividirmos os blocos, optamos por fazer com que as informações gerenciais do novo ponteiro informem que ele tem um conteúdo de tamanho 24 bytes ao invés de 10 bytes, ou seja, o tamanho real do novo bloco mais o tamanho que ficaria "livre" na memória.
Caso essa decisão não tivesse sido tomada, o cálculo do início do bloco seguinte seria afetado fazendo com que todas as referências na heap fossem perdidas nos causando ocasionalmente um segmentation fault.